# -*- coding: utf-8 -*-
"""
Created on Tue Jul 28 14:31:59 2020

@author: niili
"""
import numpy as np

#------------------------------------------------------------------------------

"""
1_6_4

Создайте и напечатайте (с помощью функции print) массив класса np.ndarray 
ширины 4 и высоты 3 с двойками на главной диагонали и единицами на первой 
диагонали над главной, т.е. воплощение матрицы
"""
"""
mat = np.eye(3, 4, k=0)
mat = mat * 2
mat = mat + np.eye(3, 4, k=1)

#print(mat)
"""
#------------------------------------------------------------------------------

"""
1_6_6

Массив, который нужно было создать в предыдущей задаче, хранится в переменной 
mat. Превратите его в вертикальный вектор и напечатайте.
"""
"""
mat = mat.reshape(12,1) # 12 строк и 1 столбец
print(mat)
"""

# заодно посмотрела на mat = mat.flatten()\
# и убедилась, что transpose не транспонирует одномерные массивы

#------------------------------------------------------------------------------

"""
1_7_11
У нас есть набор данных: знания о длине тормозного пути и скорости для трёх 
автомобилей.
D    V 
10    60
7    50
12    75

Напишите через запятую оценки коэффициентов линейной регрессии D на V, т.е. 
β^​0​, β^1 для модели D=β0+β1V+ε с точностью до трёх знаков после точки.

"""
"""
x = np.array([[1, 60],[1, 50,], [1, 75]])
y = np.array([[10], [7], [12]])

xt = np.transpose(x)
xt_mul_x = np.dot(xt, x)
inv_xt_mul_x = np.linalg.inv(xt_mul_x)
inv_mul_xt = np.dot(inv_xt_mul_x, xt)
b = np.dot(inv_mul_xt, y)
"""
#------------------------------------------------------------------------------

# в шаге 2_4_4 есть запись np.array(m,1) и np.array(m,)
# хочу своими глазами посмотреть в чем разница
"""
x = np.array([1,2])
print(x.shape)  # (2,)
y = np.array([[5],[3]])
print(y.shape)  #(2,1)
# оба - вектор-столбец. Но разница есть =))
"""
#------------------------------------------------------------------------------

# поиск ошибок в шаге 3_2 реализация поиска ошибок в слое l при известных 
# ошибках в слое l+1


n_e = (3,1)
E = np.ones(n_e)

deltas_l = np.zeros(6)

a = np.ones([3,1])
b = np.ones([3,1])

a = [[1], [2], [3]]

mul_2 = a * b

sub = E - a

mul = mul_2 * (E - a)

print(mul_2)